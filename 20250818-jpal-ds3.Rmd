---
title: "20250819-jpal-ds code-q3"
author: "Siphiwe Bogatsu"
Purpose: "Build anonymised service request dataset augmented with wind data"
date: "2025-08-19"
output: html_document
---

# ------------------------- Packages -----------------------------------------
# Use pacman for convenience; fall back to install if needed

```{r}
# Use pacman for convenience; fall back to install if needed
if (!requireNamespace("pacman", quietly = TRUE)) install.packages("pacman")

pacman::p_load(
  tidyverse, readr, sf, janitor, readODS, lubridate,
  here, logger, checkmate, renv
)
```

# ------------------------- Global options -----------------------------------
# Pin timezone & printing for consistent behavior across machines

```{r}
Sys.setenv(TZ = "Africa/Johannesburg")
options(
  readr.show_col_types = FALSE,
  scipen = 999
)
```
# ------------------------- Logging ------------------------------------------

```{r}

log_info("Build started at {format(Sys.time(), '%Y-%m-%d %H:%M:%S %Z')}")
```

# ------------------------- Paths & Constants --------------------------------
```{r}
sr_hex_path   = "sr_hex.csv.gz"
cct_sub_path  = "cct-suburb-level.gpkg"

wind_url      = "https://www.capetown.gov.za/_layouts/OpenDataPortalHandler/DownloadHandler.ashx?DocumentName=Wind_direction_and_speed_2020.ods&DatasetDocument=https%3A%2F%2Fcityapps.capetown.gov.za%2Fsites%2Fopendatacatalog%2FDocuments%2FWind%2FWind_direction_and_speed_2020.ods"

# CRS:
# WGS84 (EPSG:4326) = Project to UTM 34S (EPSG:32734). Units in meters.
CRS_WGS84   = 4326L
CRS_PROJECT = 32734L

BELLVILLE_SOUTH_NAME = "Bellville South"
BUFFER_RADIUS_M      = 1852  # ~1 arc-minute at mid-latitudes; 

```

# ------------------------- Helpers: Validation ------------------------------
```{r}
require_cols = function(df, cols) {
  
  missing = setdiff(cols, names(df))
  assert_true(
    length(missing) == 0,
    .var.name = paste0("Missing columns: ", paste(missing, collapse = ", "))
  )
}
```

# ------------------------- Data loaders -------------------------------------
```{r}
load_service_requests = function(path) {
  
  log_info("Loading service requests: {path}")
  df = read_csv(path) |>
              clean_names()

  # Basic column checks used later
  require_cols(df, c("longitude", "latitude", "creation_timestamp",
                     "completion_timestamp", "h3_level8_index"))
  
  df
}

load_suburbs = function(path) {
  
  log_info("Reading suburb polygons: {path}")
  st_read(path, quiet = TRUE) |>
               st_transform(CRS_PROJECT)
}

download_and_read_wind = function(url) {
  
  log_info("Downloading wind ODS: {url}")
  tmp   = tempfile(fileext = ".ods")
  utils::download.file(url, destfile = tmp, mode = "wb", quiet = TRUE)
  wind  = read_ods(tmp, sheet = "Sheet1", col_names = TRUE, skip = 1)

  # The file structure places fields in ...1, ...4, ...5 and has header/footer rows.
  # Keep only the needed columns and rows; parse the datetime.
  wind |>
         select(`...1`, `...4`, `...5`) |>
         rename(
      date           = `...1`,
      wind_direction = `...4`,
      wind_speed     = `...5`
                              ) |>
        slice(4:(dplyr::n() - 8)) |>
        mutate(date = lubridate::dmy_hm(date)) |>
    (\(df) {
      # coerce numerics
      df$wind_speed     = suppressWarnings(as.numeric(df$wind_speed))
      df$wind_direction = suppressWarnings(as.numeric(df$wind_direction))


      df
    })()
}

```

# ------------------------- Geoprocessing steps ------------------------------

```{r}
make_sr_points = function(sr_hex_df) {
  
  log_info("Converting SR to sf points (EPSG:{CRS_PROJECT})")
  
  sr_hex_df |>
    filter(!is.na(longitude), !is.na(latitude)) |>
    st_as_sf(coords = c("longitude", "latitude"), crs = CRS_WGS84) |>
    st_transform(CRS_PROJECT)
}

bellville_south_buffer = function(suburbs, radius_m = BUFFER_RADIUS_M) {
  
  log_info("Building Bellville South centroid buffer (r = {radius_m} m)")
  
  assert_true("SP_NAME" %in% names(suburbs), .var.name = "SP_NAME in suburbs")
  bs_centroid = suburbs |>
    filter(SP_NAME == BELLVILLE_SOUTH_NAME) |>
    st_union() |>
    st_centroid()

  st_buffer(bs_centroid, dist = radius_m)
}

augment_with_wind = function(sr_pts_sf, wind_df) {
  
  log_info("Augmenting SR with wind data by nearest hour join")
  
  sr_pts_sf |>
    mutate(crt_hr_key = round_date(creation_timestamp, "hour")) |>
    inner_join(wind_df, by = c("crt_hr_key" = "date"))
}

anonymise_sr = function(sr_aug_df) {
  
  log_info("Anonymising SR: dropping geometry & exact timestamps, binning to 6h")
  
  out = sr_aug_df |>
    st_drop_geometry() |>
    mutate(
      creation_6hr_start   = floor_date(creation_timestamp, unit = "6 hours"),
      creation_6hr_end     = creation_6hr_start + hours(6),
      completion_6hr_start = floor_date(completion_timestamp, unit = "6 hours"),
      completion_6hr_end   = completion_6hr_start + hours(6)
    ) |>
    select(
      # Keep anonymised spatial identifier if present:
      h3_level8_index,
      # Retain any other non-identifying attributes you care about:
      everything(),
      -c(crt_hr_key, creation_timestamp, completion_timestamp,
         notification_number, reference_number)
    ) |>
    mutate(across(where(is.character), tolower))

  # Validate we still have the H3 index
  require_cols(out, "h3_level8_index")
  out
}

```

# ------------------------- Main pipeline ------------------------------------

```{r}
main = function() {
  
  # Load inputs
  sr_hex_df = load_service_requests(sr_hex_path)
  suburbs   = load_suburbs(cct_sub_path)
  wind_df   = download_and_read_wind(wind_url)

  # Geometry
  sr_points = make_sr_points(sr_hex_df)
  bs_buf    = bellville_south_buffer(suburbs)

  # Spatial subset: SR within buffer
  log_info("Filtering SR within Bellville South buffer")
  sr_within = st_filter(sr_points, bs_buf)

  # Temporal augment (nearest hour)
  sr_nearest_hr = augment_with_wind(sr_within, wind_df)

  # Anonymise
  sr_final = anonymise_sr(sr_nearest_hr)

  # Basic sanity checks
  log_info("Validating output")
  
  assert_true(nrow(sr_final) > 0, .var.name = "rows in output")
  

  invisible(sr_final)
}

```
# ------------------------- Run ------------------------------------------------

```{r}
tryCatch(
  {
    result = main()
    log_success("Build anonymised service request dataset augmented with wind data completed OK. Rows: {nrow(result)}")
  },
  error = function(e) {
    log_error("Build FAILED: {conditionMessage(e)}")
    stop(e)
  }
)
```
#-------------------------- Comments on Anonymisation ---------------------------------
I anonymise locations by keeping only the $H3$ index at resolution $8$. $H3$â€™s official tables report an average edge length \approx $531$ m and area \approx $0.737$ $km^2$  for res-8 cells. Therefore, the precise position of any request is coarsened to a hex region with radius \approx $531$ m (apothem \approx $460$ m), ensuring spatial precision no finer than ~500 m while preserving neighbourhood-scale signal.Lastly, I anonymise the exact timestamps (down to the second) by binning the requests into 6-hour windows. 

With spatial anonymisation, an observer can no longer tell which specific residence the request came from; at best, they know the request was somewhere within a hex ~$500-600$ m across. That is enough for neighbourhood-scale analysis but removes the risk of singling out individuals or their homes. On the hand removing the exact timestamps (down to the second) prevents identifying individuals based on exact activity patterns (e.g., "who reported at 02h37 AM on Tuesday). The coarser window still allows analysis of daily/diurnal patterns (morning vs evening trends), but makes it infeasible to match service requests to a resident's personal routine. I also, with caution, remove the reference number and the notification number, as I do not enough information on which from the two is sensitive. 




